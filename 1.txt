1

#include <stdio.h>
#include <unistd.h>

int main() {
    printf("The process ID is %d\n", (int) getpid());
    printf("The parent process ID is %d\n", (int) getppid());
    return 0;
}


2


#include <stdlib.h>

int main() {
    int return_value;
    return_value = system("ls -l /");
    return return_value;
}


3

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t child_pid;
    
    printf("The main program process ID is %d\n", (int) getpid());
    
    child_pid = fork();
    
    if (child_pid != 0) {
        printf("This is the parent process ID, with id %d\n", (int) getpid());
        printf("The child process ID is %d\n", (int) child_pid);
    } else {
        printf("This is the child process ID, with id %d\n", (int) getpid());
    }
    
    return 0;
}


4


#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

void show_return_status(void) {
    pid_t childpid;
    int status;

    childpid = wait(&status); 
    if (childpid == -1) {
        perror("Failed to wait for child");
    } else if (WIFEXITED(status)) {
        printf("Child %ld terminated with return status %d\n", (long)childpid, WEXITSTATUS(status));
    }
}

int main() {
    pid_t pid = fork();
    if (pid == -1) {
        perror("Failed to fork");
        return 1;
    } else if (pid == 0) {
        // Child process
        _exit(42); // Exit with a specific status
    } else {
        // Parent process
        show_return_status(); // Call the function to show the return status
    }

    return 0;
}

5

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(void) {
    pid_t childpid;
    childpid = fork();

    if (childpid == -1) {
        perror("Failed to fork");
        return 1;
    }

    if (childpid == 0) {

        execl("/bin/ls", "ls", "-l", NULL);
        perror("Child failed to exec ls");
        return 1;
    } else {

        if (childpid != wait(NULL)) {
            perror("Parent failed to wait due to signal or error");
            return 1;
        }
    }

    return 0;
}


6


#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h> 

int main() {
    pid_t child_pid;


    child_pid = fork();

    if (child_pid < 0) {

        perror("Failed to fork");
        return 1;
    }
    else if (child_pid > 0) {

        printf("Parent process sleeping for 60 seconds...\n");
        sleep(60);
    }
    else {

        printf("Child process exiting immediately.\n");
        exit(0);
    }

    return 0;
}


7

#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>

int main() {
    pid_t pid;
    char *msg;
    int n;

    printf("Program starts\n");

    pid = fork();
    
    switch(pid) {
        case -1:
            perror("Fork error");
            exit(EXIT_FAILURE);
        case 0:
            msg = "This is the child process";
            n = 5;
            break;
        default:
            msg = "This is the parent process";
            n = 3;
            break;
    }

    while(n > 0) {
        puts(msg);
        sleep(1);
        n--;
    }

    return 0;
}



8

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/wait.h>

#define SIZE 1024

void do_child_proc(int pfd[2]);
void do_parent_proc(int pfd[2]);

int main() {
    int pfd[2];
    int ret_val, nread;
    pid_t pid;

    ret_val = pipe(pfd);
    if (ret_val == -1) {
        perror("pipe error\n");
        exit(ret_val);
    }

    pid = fork();
    switch(pid) {
        case -1:
            perror("Fork error\n");
            exit(EXIT_FAILURE);
        case 0:
            do_child_proc(pfd);
            exit(EXIT_SUCCESS);
        default:
            do_parent_proc(pfd);
            wait(NULL); 
            exit(EXIT_SUCCESS);
    }

    return 0;
}

void do_child_proc(int pfd[2]) {
    int nread;
    char buf[SIZE];

    printf("Child process: Reading from pipe...\n");
    close(pfd[1]); 

    while ((nread = read(pfd[0], buf, SIZE)) > 0) {
        buf[nread] = '\0'; 
        printf("Child Read: %s\n", buf);
    }

    if (nread == -1) {
        perror("Read error in child\n");
        exit(EXIT_FAILURE);
    }

    close(pfd[0]); 
    printf("Child process: Exiting...\n");
    exit(EXIT_SUCCESS);
}

void do_parent_proc(int pfd[2]) {
    char ch;
    char buf[SIZE];
    int index = 0;

    printf("Parent process: Writing to pipe...\n");
    close(pfd[0]); 

    printf("Enter a message (max %d characters): ", SIZE);
    while ((ch = getchar()) != '\n' && index < SIZE - 1) {
        buf[index++] = ch;
    }
    buf[index] = '\0'; 

    write(pfd[1], buf, strlen(buf) + 1);

    close(pfd[1]); 
    printf("Parent process: Exiting...\n");
}




